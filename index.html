<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Particles - Gesture Solar System</title>
    <style>
        body { margin: 0; background: #000; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; }

        #ui {
            position: absolute; top: 30px; left: 30px; z-index: 10;
            background: rgba(0, 0, 0, 0.7); border: 1px solid rgba(0, 255, 255, 0.2);
            padding: 25px; border-radius: 15px; width: 260px; backdrop-filter: blur(10px);
        }

        h1 { font-size: 1rem; margin: 0; color: #00ffff; letter-spacing: 3px; text-transform: uppercase; }
        .current-target { font-size: 1.5rem; font-weight: bold; margin: 10px 0; color: #fff; }
        
        .gesture-card {
            background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; margin-top: 15px; font-size: 0.75rem;
        }

        #video-preview {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px; border-radius: 10px;
            border: 1px solid #444; transform: scaleX(-1);
        }

        .status { color: #00ff88; font-weight: bold; font-family: monospace; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Celestial Navigation</h1>
        <div id="targetName" class="current-target">Solar System</div>
        
        <div class="gesture-card">
            üñêÔ∏è <strong>Scale:</strong> Open hand to expand orbits<br>
            ‚úåÔ∏è <strong>Lock:</strong> Peace sign to freeze view<br>
            üñï <strong>Navigate:</strong> Middle finger to jump planets
        </div>

        <div style="margin-top:20px; font-size: 0.7rem; opacity: 0.7;">
            SYSTEM STATUS: <span id="sysStatus" class="status">INITIALIZING...</span>
        </div>
    </div>

    <video id="webcam" playsinline autoplay style="display:none;"></video>
    <video id="video-preview" playsinline autoplay></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        /** 1. DATA DEFINITION (Scaled for visibility) **/
        const PLANETS = [
            { name: "Sun", color: 0xffcc00, size: 2.0, dist: 0 },
            { name: "Mercury", color: 0xaaaaaa, size: 0.2, dist: 3 },
            { name: "Venus", color: 0xe3bb76, size: 0.45, dist: 5 },
            { name: "Earth", color: 0x2271b3, size: 0.5, dist: 7 },
            { name: "Mars", color: 0xe27b58, size: 0.3, dist: 9 },
            { name: "Jupiter", color: 0xd39c7e, size: 1.2, dist: 13 },
            { name: "Saturn", color: 0xc5ab6e, size: 1.0, dist: 17, ring: true },
            { name: "Uranus", color: 0xbbe1e4, size: 0.7, dist: 21 },
            { name: "Neptune", color: 0x6081ff, size: 0.7, dist: 25 }
        ];

        /** 2. THREE.JS SETUP **/
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const particleGroups = [];
        
        // Create each planet as a group of particles
        PLANETS.forEach((data, index) => {
            const count = index === 0 ? 8000 : 2000; // Sun gets more particles
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                const r = data.size * Math.pow(Math.random(), 0.5);
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                pos[i*3] = r * Math.sin(v) * Math.cos(u);
                pos[i*3+1] = r * Math.cos(v);
                pos[i*3+2] = r * Math.sin(v) * Math.sin(u);
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: data.color, size: 0.03, transparent: true, blending: THREE.AdditiveBlending
            });
            
            const points = new THREE.Points(geo, mat);
            const group = new THREE.Group();
            group.add(points);

            // Add Saturn's Rings
            if (data.ring) {
                const ringGeo = new THREE.BufferGeometry();
                const ringPos = new Float32Array(1500 * 3);
                for(let i=0; i<1500; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const rad = 1.4 + Math.random() * 0.6;
                    ringPos[i*3] = Math.cos(angle) * rad;
                    ringPos[i*3+1] = (Math.random()-0.5) * 0.05;
                    ringPos[i*3+2] = Math.sin(angle) * rad;
                }
                ringGeo.setAttribute('position', new THREE.BufferAttribute(ringPos, 3));
                const ringPoints = new THREE.Points(ringGeo, new THREE.PointsMaterial({color: 0x888888, size: 0.02}));
                group.add(ringPoints);
            }

            scene.add(group);
            particleGroups.push({ mesh: group, data: data, angle: Math.random() * Math.PI * 2 });
        });

        camera.position.set(0, 15, 30);
        camera.lookAt(0, 0, 0);

        /** 3. GESTURE LOGIC **/
        let expansion = 1.0;
        let isLocked = false;
        let navIndex = -1; // -1 = System View
        let lastNavTime = 0;

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });

        hands.onResults((results) => {
            const status = document.getElementById('sysStatus');
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // 1. Gesture Detection
                const indexUp = lm[8].y < lm[6].y;
                const middleUp = lm[12].y < lm[10].y;
                const ringUp = lm[16].y < lm[14].y;
                const pinkyUp = lm[20].y < lm[18].y;

                // NAVIGATION: Middle Finger ONLY (Middle up, others down)
                if (middleUp && !indexUp && !ringUp && !pinkyUp) {
                    const now = Date.now();
                    if (now - lastNavTime > 1000) { // Debounce 1s
                        navIndex = (navIndex + 1 >= PLANETS.length) ? -1 : navIndex + 1;
                        document.getElementById('targetName').innerText = navIndex === -1 ? "Solar System" : PLANETS[navIndex].name;
                        lastNavTime = now;
                    }
                    status.innerText = "NAVIGATING...";
                }
                // LOCK: Peace Sign
                else if (indexUp && middleUp && !ringUp) {
                    isLocked = true;
                    status.innerText = "LOCKED ‚úåÔ∏è";
                }
                // SCALE: Open Hand
                else {
                    isLocked = false;
                    status.innerText = "TRACKING";
                    const dist = Math.hypot(lm[4].x - lm[20].x, lm[4].y - lm[20].y);
                    expansion = THREE.MathUtils.lerp(expansion, 0.2 + dist * 5, 0.1);
                }
            }
        });

        const videoElement = document.getElementById('webcam');
        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { 
                await hands.send({ image: videoElement });
                document.getElementById('video-preview').srcObject = videoElement.srcObject;
            }
        });
        cameraFeed.start();

        /** 4. ANIMATION LOOP **/
        const targetCamPos = new THREE.Vector3(0, 15, 30);
        const targetLookAt = new THREE.Vector3(0, 0, 0);
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.005;

            particleGroups.forEach((p, i) => {
                if (!isLocked) {
                    p.angle += 0.01 / (p.data.dist + 1); // Orbit speed
                }
                const orbitRadius = p.data.dist * expansion;
                p.mesh.position.x = Math.cos(p.angle) * orbitRadius;
                p.mesh.position.z = Math.sin(p.angle) * orbitRadius;
                
                p.mesh.rotation.y += 0.01; // Self-spin
            });

            // Camera Navigation Logic
            if (navIndex === -1) {
                targetCamPos.set(0, 20 * expansion, 30 * expansion);
                targetLookAt.set(0, 0, 0);
            } else {
                const targetPlanet = particleGroups[navIndex].mesh;
                const offset = PLANETS[navIndex].size * 4;
                targetCamPos.set(
                    targetPlanet.position.x, 
                    targetPlanet.position.y + offset, 
                    targetPlanet.position.z + offset
                );
                targetLookAt.copy(targetPlanet.position);
            }

            // Smoothly move camera
            camera.position.lerp(targetCamPos, 0.05);
            const currentLook = new THREE.Vector3();
            // This is a simple lookAt lerp approximation
            camera.lookAt(targetLookAt);

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
